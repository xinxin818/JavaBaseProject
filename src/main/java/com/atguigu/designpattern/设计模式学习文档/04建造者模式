
建造者模式 builder pattern

    又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来(抽象类别)，使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。
    建造者模式，是一步一步构建一个复杂的对象，他允许用户只通过指定复杂对象的类型和内容就可以构建他们，用户不需要知道内部的具体构建细节。

    建造者模式的四个角色
        product (产品角色) :一个具体的产品对象。
        builder (抽象建造者)：创建一个product对象的各个部件指定的接口/抽象类。
        concreateBuilder (具体建造者)：实现接口，构建和装配各个部件。
        Director (指挥者)：构建一个使用builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，
                        一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。

    建造者模式在JDK的应用和源码分析
        java.lang.StringBuilder 中的建造者模式
        角色分析：
            Appdedable接口定义了多个append方法（抽象方法），即Appendable为抽象建造者，定义了抽象方法。
            AbstractStringBuilder 实现Appdedable接口方法， 这里的AbstractStringBuilder已经是建造者，只是不能实例化。
            StringBuilder 即充当了指挥者角色， 同时充当了具体的建造者，建造方法的实现是由AbustractStringBuilder完成，而StringBuilder继承了AbstractBuilder。

    建造者模式的注意事项和细节
        1）客户端（使用程序）不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
        2）每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便的替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。
        3）可以更加精细的控制产品的创建过程，将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
        4）增加新的具体建造者无需修改原有类库的代码，指挥者针对抽象建造者编程，系统扩展方便，符合开闭原则。
        5）建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其适用范围收到一定的限制。
        6）如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大， 因此在这种情况下，要考虑是否选择建造模式。

        7）抽象工厂模式 VS 建造者模式
            抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一些列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。
            而构建者模式则是要求按照指定的蓝图构造产品，他的主要目的是通过组装零配件而产品一个新产品。

            抽象工厂模式把一辆车认为是一个完整的、不可拆分的对象。他注重完整性；一个产品一旦找到一个工厂生产，那就是固定的型号，不会出现一个宝马工厂生产奔驰车的情况。
                那现在的问题是我们就想要一辆混合的车型，如奔驰的引擎，宝马的车轮，那该如何处理呢？使用我们的建造者模式！

            建造者模式设计一个生产车辆需要把车辆进行拆分，拆分成引擎和车辆两部分，然后由建造者进行建造，想要什么车，你只要有设计图纸就成，马上可以制造一辆车出来。
                他注重的是对零件的装配、组合、封装，他从一个细微构件装备角度看待一个对象。

            在抽象工厂模式中使用“工厂”来描述构建者，而在建造者模式中使用“车间”来描述构件者。