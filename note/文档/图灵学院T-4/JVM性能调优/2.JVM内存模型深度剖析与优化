
2.JVM内存模型深度剖析与优化

	课程内容：
		
		1.JDK体系结构与跨平台特性介绍
		2.JVM内存模型深度剖析
		3.从jvisualvm来研究下对象内存流转模型
		4.讲透 Gc Root与STW机制
		5.日均百万级订单交易系统JVM参数如何设置
		6.JVM参数设置通用模型
		
		
	java语言的跨平台性
						
						javac				java
		HelloWorld.java -> HelloWorld.class -> JVM--windows机器码-》Windows
													-linux机器码-》	Liunx
		
		JVM：
			从软件层面屏蔽不同操作系统在底层硬件与指令上的区别。
			
		类装载子系统 -》 运行时数据区 -》 字节码执行引擎
					
		
		
		
=====================================================================
儒猿技术窝：

JVM有那些内存区域，分别是用来干嘛的？

	JVM会加载类到内存里来攻后续运行，这些类加载到内存后，放在哪？

		内存区域存放加载的类 (元数据空间，Metaspace，	存放我们自己写的各种类相关的信息。)
		内存区域创建的对象
		内存区域存放运行方法使用

		为了我们写好的代码在运行过程中根据需要来使用，JVM必须划分出不同的内存区域。

		我们写好的java代码会被翻译成字节码，对应各种字节码指令：
			java代码通过jvm跑起来的第一件事，首先java带啊吗被编译成字节码指令，然后字节码指令一定会被一条一条执行，这样才能实现我们写好的代码执行的效果。
			当JVM加载类信息到内存之后，实际就会使用自己的字节码执行引擎，去执行我们写的代码编译出来的代码指令。
			执行字节码指令的时候，JVM里就需要一个特殊的内存区域，就是程序计数器。
			这个程序计数器就是用来记录当前执行的字节码指令的位置的，也就是记录目前执行到了那一条字节码指令。
			JVM支持多个线程，所以写好的代码可能会开启多个线程并发执行不同的代码，所以会有多个线程来并发的执行不同的代码指令。
			因此每个线程都会有自己的一个程序计数器，专门记录当前这个线程目前执行到了哪一条字节码指令了。


		java虚拟机栈
			在方法里，我们经常会定义一些方法内的局部变量
			JVM必须有一块区域是来保存每个方法内的局部变量等数据的，这个区域就是java虚拟机栈
			如果线程执行了一个方法，就会对这个方法调用创建对应的一个栈帧
			栈帧里就有这个方法的局部变量表，操作数栈，动态链接，方法出口等东西。

			java虚拟机栈这个组件的作用：
				调用执行任何方法时都会给方法创建栈帧然后入栈
				在栈帧里存放了这个方法对应的局部变量之类的数据，包括这个方法执行的其他相关的信息，方法执行完毕后就出栈。
				每个线程在执行代码时，除了程序计数器之外，还搭配了一个java虚拟机栈内存区域来存放每个方法中的局部变量表。

		java堆内存
			存放我们在代码中创建的各种对象
			java堆内存区域里放入类似main方法里的"new ReplicaManager"ReplicaManager的对象，
			在线程执行main方法代码的时候，会在main方法对应的栈帧的局部变量表里，让一个引用类型的"replicaManager"局部变量来存放ReplicaManager对象的地址。
			相当于局部变量表里的"replicaManager"指向了Java堆内存里的ReplicaManager对象。

		其他内存区域
			JDK很多底层API里，比如IO相关的，NIO相关的，网络Socket相关的，
			走的是navite方法去调用本地操作系统里的一些方法，可能调用的都是C语言写的方法，或者一些底层类库。
			在调用这种navite方法的时候，就会有线程对应的本地方法栈，这个里面也是跟java虚拟机栈类似的，存放各种native方法的局部变量表之类的信息。

			还有一个区域是不属于JVM的，通过NIO中的allocateDirect这种API，可以在java堆外分配内存。然后通过java虚拟机里的DitrctByteBuffer来引用鹤操作堆外内存空间。


=====================================================================
005 JVM的垃圾回收机制是干嘛的？为什么要垃圾回收？

		代码执行结束后，对应的栈帧从main线程的java虚拟机栈里出栈，栈帧内的局部变量指向java堆内存里的实例对象没有了。java堆内存里的实例对象没有人引用它了。
		我们在java堆内存里创建的对象，都是占用内存资源的，而且内存资源有限。需要垃圾回收清理内存。
		JVM的垃圾回收机制，是一个后台自动运行的线程。
		只要启动一个JVM进程，它就会自带这么一个垃圾回收的后台线程。这个线程会在后台不断检查JVM堆内存中的各个实例对象。

		如果某个实例对象没有任何一个方法的局部变量指向它，也没有任何一个类的静态变量，包括常量等地方在指向它。
		那么这个垃圾回收线程，就会把这个没人指向的实例对象给回收掉，从内存里清除掉，让他不再占用任何内存资源。
		这样的话，这些不再被人指向的对象实例，即JVM中的垃圾，就会定期的被后台垃圾回收线程清理掉，不断释放内存空间。

	我们创建的那些对象，到底在java堆内存里占用多少内存空间呢？

		一个对象堆内存空间的占用，大致分为两块：

			一个是对象自己本身的一些信息
			一个是对象的实例变量作为数据占用的空间

				比如对象头，如果在64为的linux操作系统上，占用16字节，
				如果你的实例对象内部有个int类型的实例变量，他会占用4个字节，如果是long类型的实例变量，会占用8字节。
				如果是数组、map之类的，会占用更多的内存。

	加载到方法区的类会被垃圾回收吗？什么时候被回收？为什么呢？

	问题：
		如果我有一个静态的成员变量int，那我多线程更改是否会有线程安全问题，为什么？
			答：静态成员变量，它在内存里只有一份，就是属于类的。你多个线程并发修改，一定会有并发问题，可能导致数据出错。


=====================================================================

3. JVM分代模型：年轻代、老年代、永久代

	我们平时代码里创建出来的对象，一般就是两种：
		1.短期存活的，分配在java堆内存之后，迅速使用完就回被垃圾回收
		2.长期存活的，需要一直生存在java堆内存里，让程序后续不停的去使用

	大部分正常对象，都是有限在新生代分配内存的。

	什么情况下回触发新生代的垃圾回收？
		java堆内存里囤积了大量的对象，然后这些对象都是之前有人引用，比如各种各样的方法中的局部变量，但是现在没人引用了。
		如果新生代我们预先分配的内存空间，几乎都被全部对象给占满了。此时假设我们代码继续运行，他需要在新生代里去分配一个对象，
		这个时候就会触发一次新生代内存空间的垃圾回收。新生代内存空间的垃圾回收，也称为Minor GC，也叫 Young GC。
		他会尝试把新生代里那些没有人应用的垃圾对象，都给回收掉。

	长期存活的对象会躲过多次垃圾回收

		新生代可能随着系统的运行，不断的创建对象，然后让新生代变满，接着垃圾回收一次，大量没被引用的对象被回收掉。
		也有一直存活在新生代里的对象仍然被引用，不会被回收。
		如果一个实例对象在新生代中，成功的在15次垃圾回收之后，还没被回收掉，就说明他已经15岁了，就会被认为会长期存货在内存里的对象。
		然后会被转移到java堆内存的老年代中去，顾名思义，老年代就是放那些年纪很大的对象。

	新生代、老年代的对象分配

		新生代、老年代 复杂的分配机制：
			新色会给你带垃圾回收之后，因为存货对象太多，导致大量对象直接进入老年代
			特别大的超大对象直接不经过新生代就进入老年代
			动态对象年龄判断机制
			空间担保机制

		对象内存分配总结：
			先理解对象优先分配在新生代
			新生代如果对象满了，会出发Minor GC回收掉没有人引用的垃圾对象
			如果有对象躲过了十多次垃圾回收，就会放入老年代里
			如果老年代也满了，那么也会触发垃圾回收，把老年代里没人引用的垃圾对象清理掉

=====================================================================






















		
		
		
		
		
		