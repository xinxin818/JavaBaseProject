
=====================================================================

线上系统部署时如何设置JVM内存大小？

	JVM内存分配中，核心的几个参数：
		1.-Xms：java堆内存的大小
		2.-Xmx：Java堆内存的最大大小
		3.-Xmn：java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小了
		4.-XX：PermSize：永久代大小
		5.-XX：MaxPermSize：永久代最大带线啊哦
		6.-Xss：每个线程的栈内存大小
		
	说明：
		-Xms 和 -Xmx ，分别用于设置java堆内存的刚开始的大小，以及允许扩张到的最大大小
			这对参数，通常设置为完全一样的大小。这两个参数，是用来限定java堆内存的总大小的。
		-Xmn ，用来设置java堆内存中的新生代的大小，然后扣除新生代大小之后的剩余内存就是老年代的内存大小。
		-XX:PermSize和-XX:MaxPermSize,分别限定了永久代大小和永久代的最大大小
			通常这两个数值也是设置为一样的。
			如果是JDK1.8后的版本，那么这俩参数被替换为了-XX:MetaspaceSize和-xx:MaxMetaspaceSize
		-Xss:这个参数限定了每个线程的栈内存大小
			每个线程都有一个自己的虚拟机栈，每次执行一个方法，都会将方法的栈帧压入线程的栈里，方法执行完毕，栈帧就会从线程的栈里出栈。
	
		测试：
			1. 带main()方法的类，右击，debug as-》debug configuration-》arguments-》VM arguments-》输入JVM参数。
				比如： -Xms512M -Xmn512M -Xmn256M -Xss1M -XX:PermSize=128M -XX:MaxPermSize=128M
			2. 在线上部署系统设置JVM参数：
				比如：Java -Xms512M -Xmn512M -Xmn256M -Xss1M -XX:PermSize=128M -XX:MaxPermSize=128M -jar App.jar
		
		通过案例，学习参数优化设置的预告：
			1.分析一个支付系统的核心业务流程，结合JVM相关知识，探究JVM内存相关的这些核心参数到底在我们上线一个生产系统的时候，
			   针对预估的并发压力，到底应该如何合理的给出一个未经过调优的比较合理的初始值。
			2.另外分析各种参数在设置的时候有哪些考虑的点，java堆内存到底需要多大？新生代和老年代的内存分别需要多大？永久代和虚拟机栈分别需要多大？
			3.JVM参数到底该如何设置，一定是根据不同而业务系统他具体的一些场景来调整的。一切都要从案例触发， 结合业务场景来分析。
			分析：哪些是短周期生存周期的对象，哪些是长生存周期的对象。脑子里简历系统在JVM中运行时的一个爱国i粘土，要有这个意识，才能更好的进行JVM调优。

=====================================================================
		
011 案例实战：每日百万交易的支付系统，如何设置JVM堆内存大小？

	支付系统背景引入
	支付的核心业务流程
	每日百万交易的支付系统的压力在哪里
	支付系统每秒钟需要处理多少笔支付订单
	每个支付订单处理要耗时多久
	每个支付订单大概需要多大的内存空间
	每秒发起的支付请求对内存的占用
	让支付系统运行起来分析一下
	对完整的支付系统内存占用需要进行预估
	支付系统的JVM堆内存应该怎么设置


	支付的核心业务流程：
	
		1.用户在商城系统提交支付的一个订单的请求，接着商城系统把这个请求提交给支付系统，支付系统就会生成一个支付订单，此时订单状态是“待支付”的状态。
		2.支付系统指引用户跳转到付款页面，选择一个付款方式
		3.用户发起实际支付请求，支付系统把实际支付请求转交给第三方支付渠道，比如微信或者支付宝，他们会去处理支付请求进行资金转移。
		4.如果微信或者支付宝处理完支付之后，就会返回支付结果给支付系统，支付系统可以更细心你自己本地的支付订单的状态变成“已完成”。
		
		当然，其实一个完整的支付系统还包括很多东西。
		比如，还要负责对账以及跟合作商户之间的资金清算，支付系统得包括：应用管理，账户管理，渠道管理，支付交易，对账管理，清算管理等各种功能模块，但是我们这里就关注最核心的支付流程即可。
		
	每日百万交易的支付系统的压力在哪里？

		一般到达百万交易，要不然是国内最大的互联网公司，要不就是一个通用性第三方支付平台，对接各种APP的支付交易。
		业务流程中最核心的环节就是，用户发起支付请求的时候，会生成一个支付订单。
		这个支付订单需要记录清楚比如是谁发起支付？对哪个商户的支付？通过哪个渠道进行支付？还有发起支付的时间？等等，诸如此类的信息。
		在JVM的角度来看，就是每天会在JVM中创建上百万个支付订单对象。
		
		我们的支付系统，高并发访问、高性能处理请求、大量的支付订单数据需要存储，等等技术难点。
		
		但是抛开这些系统架构层面的东西，单单JVM层面，我们的支付系统最大的压力，就是每天JVM内存里会频繁的创建和销毁100万个支付订单，所以就牵扯到一个核心的问题：
			1.我们的支付系统需要部署多少台机器？
			2.每台机器需要多大的内存空间？
			3.每台机器上启动的JVM需要分配多大的堆内存空间？
			4.给JVM多大的内存空间才能保证可以支撑这么多的支付订单在内存里的创建，而不会导致内存不够直接崩溃？
		这就是我们需要考虑的核心问题。
		
	支付系统每秒钟需要处理多少笔支付订单
		要解决线上系统最核心的一个参数，也就是JVM堆内存大小的合理设置，首先第一个要计算的，就是每秒钟我们的系统要处理多少笔支付订单。
		假设每天高峰期大概是几个小时，用100万平均分配到几个小时里，那么大概每秒100笔订单左右，咱们就以每秒100笔订单来计算一下好了。
		假设我们的支付系统部署了3台机器，每台机器实际上每秒大概处理30笔订单。
		
	每个支付订单处理要耗时多久
		如果用户发起一次支付请求，那么支付需要在JVM中创建一个支付订单对象，填充进去数据，然后把这个支付订单写入数据库，还可能会处理一些其他的事情。
		假设一次支付请求的处理，包含一个支付订单的创建，大概需要1秒钟的时间。
		那么大体上你的脑子里可以出现的一个流动的模型，应该是每台机器1秒钟接收到30笔支付订单的请求，然后再JVM的新生代里创建了30个支付订单的对象，做了写入数据库等处理。
		接着1秒之后，这30个支付订单就处理完毕，然后对这些支付订单对象的引用就回收了，这些订单在JVM的新生代里就是没人应用的垃圾对象了。
		接着再是下一秒来30个支付订单，重复这个步骤。
	
	每个支付订单大概需要多大的内存空间
		直接根据支付订单类中的实例变量的类型来计算就可以了。
		比如支付订单类，一个Integer类型的变量数据是4个字节，Long类型的变量数据是8个字节，还有别的类型的变量数据占据多少字节。就可以计算出每个支付订单对象大致占据多少字节。
		一般来说，比如支付订单这种核心类，就按20个实例变量来计算，然后一般大概一个对象也就在几百字节的样子。
		我们算他大点好了，就算一个支付订单对象占据500字节的内存空间，不到1KB。
		
	每秒发起的支付请求对内存的占用
		之前说过，假设有3台机器，每台机器每秒钟处理30笔支付订单的请求，那么在这1秒内，肯定有方法里的局部变量在引用这些支付订单的。
		那么30个支付订单，大概占据的内存空间是 30 * 500字节 = 15000字节，大概也就15KMB而已。其实是非常小的。
		
	让支付系统运行起来分析一下
		每秒30个字符请求，创建30个支付订单对象，也就占据kb几百的内存空间而已
		接着1秒后，这30个对象就没有人引用了，就成了新生代里的垃圾
		下一秒请求过来，我们的系统持续的创建支付订单对象，不停在新生代里放入30个支付订单，然后新生代里的对象会持续的累积和增加。
		知道有一刻，发现可能新色会给你带里都有几十万个对象了，此时占据了几百MB的空间了，可能新生代空间都快满了。
		会触发Minor GC，就把新生代里的垃圾对象都给回收掉了，腾出内存空间，然后继续来在内存里分配新的对象。
		这就是这个业务系统的运行模型。
	
	对完整的而支付系统内存占用需要进行预估
		之前的分析，全部都是基于一个核心业务流程中欧给的一个支付订单对象来分析的，其实那只是一小部分而已。
		真实的支付系统线上运行，肯定每秒会创建大量其他的对象，但是我们结合这个访问压力以及核心对象的内u你占据，大致可以来估算一下整个支付系统每秒钟大致会占据多少内存空间。
		估算的话，可以把之前的计算结果扩大10-20倍。也就是每秒钟除了内存里创建支付订单对象，还会创建其他数十种对象。
		每秒钟创建出来的被栈内存的局部变量引用的对象大致占据的内存空间就在几百kb-1mb之间。
		下一秒继续来新的请求创建大概1mb的对象放在新生代里，接着变成垃圾，再来下一秒。
		循环多次之后，新生代垃圾太多，就会触发Minor GC回收掉这些垃圾。这就是一个完整系统的大致JVM层面的内存使用模型。
		
	支付系统的JVM堆内存应该怎么设置
		
		一般来说这种线上业务系统，常见的机器配置是2核4G，或者是4核8G
		
		如果用2核4G的机器来部署有点紧凑。因为机器有4G，但是机器本身也要用一些内存空间，最后你的JVM进程最多就是2G内存。
		这2G还得分配给方法区、栈内存、堆内存几块区域，那么堆内存最多就是个1G多的内存空间。
		然后堆内存还分为新生代和老年代，老年代总需要放置系统的一些长期存活的对象，怎么也得给几百MB的内存空间，新生代可能也就几百MB的内存了。
		我们上述的核心业务流程仅仅是针对要给支付订单对象分析的，实际上如果扩大10-20倍换成对完整系统的预估之后，大致每秒会占据1MB左右的内存空间。
		如果新生代就几百MB的内存空间，会导致运行几百秒之后，新生代内存空间就满了，此时就得触发Minor GC了。
		频繁触发Minor GC，会影响线上系统的性能稳定性。
		
		可以考虑采用4核8G的机器来部署支付系统，JVM进程只是可以给4G以上内存，新生代在里面至少可以分配到2G内存空间。
		可以做到可能新生代每秒多1MB左右的内存，但是需要将近半小时到1小时才会让新生代触发Minor GC，就大大降低了GC的频率。
		举个例子：机器采用4核8G，然后-Xms和-Xmx设置为3G，给整个堆内存3G内存空间，-Xmn设置为2G，给新生代2G内存空间。
		假设业务量如果很大， 可以考虑不止部署3台机器，可以横向扩展5台机器，或者10台机器，这样每台机器处理的请求更少。对JVM的压力更小。
		
		
=====================================================================
		
012 案例实战：每日百万交易的支付系统，JVM栈内存与永久代大小该如何设置？

	基于案例，说说不合理设置内存的反面案例
	大促期间，瞬间访问量增加十倍
	少数请求需要几十秒处理，导致老年代内存占用变大
	老年代对象越来越多导致频繁垃圾回收
	反面案例总结
	如何合理设置永久代大小？
	如何合理设置栈内存大小？
	
	
	

=====================================================================



=====================================================================

		
		