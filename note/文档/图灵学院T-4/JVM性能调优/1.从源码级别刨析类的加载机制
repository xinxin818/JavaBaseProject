
1.从源码级别刨析类的加载机制
	
	课程内容：
	
		1.从Java.exe开始将头java类加载运行全过程
		2.从JDK源码级别剖析JVM核心类加载器
		3.从JDK源码级别剖析类加载双亲委派机制
		4.手写自定义类加载器打破双亲委派机制
		5.Tomcat类加载机制深度剖析
		6.手写Tomcat类加载器实现多版本代码共存隔离
	
	
	类加载运行全过程
		加载》》验证》》准备》》解析》》初始化》》使用》》卸载
		
		加载：代码中用到这个类的时候去加载

		验证：检验加载进来的".class"字节码文件中的内容是否符合指定的规范
		准备：给这个类分配一定的内存空间，给他里面的类变量（也就是static修饰的变量）分配内存空间来一个默认的初始值。
		解析：把符号引用替换为直接引用的过程。这个部分内容复杂，涉及到JVM的底层

		初始化：
			static 修饰的 "new ReplicaManager()"来实例化类的对象，此时就会出发类的加载安东初始化的全过程，把这个类准备好，然后再实例化一个对象出来。
			或者是包含"main()"方法的伫列，必须是立马初始化的。
			如果初始化一个类的时候，发现他的弗雷还没初始化，那么必须先初始化他的父类。


	类加载器和双亲委派机制

			搞明白了整个类加载从触发时机到初始化的过程，它的实现必须是依靠类加载器来实现的。

		引导类加载器（启动类加载器）：Bootstrap ClassLoader，负责加载我们在机器上安装的java目录下的核心类的。
		扩展类加载器	：Extension ClassLoader,加载java安装目录下的 lib\ext目录。
		应用类加载器 ：Application ClassLoader，加载"ClassPath"环境变量所指定的路径中的类。
		自定义加载器 ：自定义类加载器，根据自己的需求加载你的类。
		
		类加载初始化过程：
			JVM启动sun.mics.Laucher，它初始化使用了单例模式设计，保证一个JVM虚拟机内只有一个sun.misc.Laucher实例。
			在Launcher构造方法内部，其创建了两个类加载器，分别是sun.mics.Launcher.ExtClassLoader(扩展类加载器)和sun.sics.Launcher.AppClassLoader(应用类加载器)。
			JVM默认使用Launcher的getClassLoader()方法返回的类加载器AppClassLoader的实例加载我们的应用程序。
		
		双亲委派机制：		先找父亲加载，再找子类加载
			
			引导类加载器			|
				|				|
				|向上委托		|
				|				|
			扩展类加载器			|
				|				|父加载器加载失败由子加载器自己加载
				|向上委托		|
				|				|
			应用程序类加载器		|
				|				|
				|				|
				|				
			自定义加载器，自定义加载器	
		
		为什么使用双亲委派机制：
			1.沙箱安全机制：自己写的Java.lang.String.class类不会被加载，这样便可以防止核心API库被随意篡改。
			2.避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证被加载类的唯一性。
	
	自定义类加载器：
		
		自定义类加载器只需要继承java.lang.ClassLoader类，该类有两个核心方法，
		一个是loadClass(String,boolean),实现了双亲委派机制，
		一个是findClass，默认实现是空方法，所以我们自定义类加载器主要是重写findClass方法。
		
		打破双亲委派机制：
			用自定义类加载器加载我们自己实现的java.lang.String.class,
			重写类加载方法，实现自己的加载逻辑，不委派给双亲加载。执行报错。
				运行结果：java.lang.SecurityExcetion:prohibited package name:java.lang at java.lang.ClassLoader.preDefindClass(ClassLoader.java:659)...
	
	
	
	